# Зареждане на NFT от Smart Contract

1. Когато се зареди браузърът, да се обходи event log-ът на smart contract-a и да се взимат данните на event-a, който се вдига при създаването на NFT (Listing NFT to marketplace). За всяко NFT, взето от event-a, да се провери дали все още съществута в магазина(чрез view функция на smart contracta, където се подават директно нужните аргументи) и ако да - се зарежда на user-a, ако не - се продължава към следващото NFT, след като приключи това, се запазва в браузъра под формата на id => NFT и се слуша за нови event-и, които се емитват от smart contract-a и на база на тях се се изпълнява дадено нещо (изтриване на NFT, добавяне на NFT). Когато се рефрешне браузърът се проверява дали в storage-a му има запазени данни, ако има се взимат те, за да се предотврати повторното зареждане на всичко това.

    * В smart contract-a има **mapping(address => mapping(uint256 => marketItem))**, причината за това е да може да се ползват NFT-та с различни адреси. *Address*-ът ще сочи към contract адреса на NFT-то, *uint256* към **tokenId**-то на съответното NFT.
2. В smart contracta да има **mapping(uint256 => marketItem)**, заедно с това да има два брояча: *_itemIds* и *_itemsCount*.
    * _itemIds - Ще се увеличи с 1 винаги, когато се създаде *marketItem* в магазина, но възможно е после **mapping**-ът да сочи към изтрит *Item*, ако вече е продаден.
    * _itemsCount - Ще се увеличи винаги с 1 и ще се намали с 1, когато има движение в пазара, така винаги ще знаем колко *list*-нати *NFT*-та има и при зареждането им от smart contracta-а ще създадем масив в *memory* със зададена големина **_itemsCount**. Обхождаме от 0 до колкото на брой *id*-та има (_itemIds.current()), срещнем ли, че текущият owner e магазинът - *push*-ваме в нашия масив, който ще върнем.